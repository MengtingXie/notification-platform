// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package ioc

import (
	"context"
	"gitee.com/flycash/notification-platform/internal/api/grpc"
	"gitee.com/flycash/notification-platform/internal/domain"
	"gitee.com/flycash/notification-platform/internal/ioc"
	"gitee.com/flycash/notification-platform/internal/repository"
	"gitee.com/flycash/notification-platform/internal/repository/cache/local"
	"gitee.com/flycash/notification-platform/internal/repository/cache/redis"
	"gitee.com/flycash/notification-platform/internal/repository/dao"
	"gitee.com/flycash/notification-platform/internal/service/audit"
	"gitee.com/flycash/notification-platform/internal/service/channel"
	"gitee.com/flycash/notification-platform/internal/service/config"
	"gitee.com/flycash/notification-platform/internal/service/notification"
	"gitee.com/flycash/notification-platform/internal/service/notification/callback"
	"gitee.com/flycash/notification-platform/internal/service/provider"
	"gitee.com/flycash/notification-platform/internal/service/provider/manage"
	"gitee.com/flycash/notification-platform/internal/service/provider/metrics"
	"gitee.com/flycash/notification-platform/internal/service/provider/sequential"
	"gitee.com/flycash/notification-platform/internal/service/provider/sms"
	"gitee.com/flycash/notification-platform/internal/service/provider/sms/client"
	"gitee.com/flycash/notification-platform/internal/service/provider/tracing"
	"gitee.com/flycash/notification-platform/internal/service/quota"
	"gitee.com/flycash/notification-platform/internal/service/scheduler"
	"gitee.com/flycash/notification-platform/internal/service/sender"
	"gitee.com/flycash/notification-platform/internal/service/sendstrategy"
	manage2 "gitee.com/flycash/notification-platform/internal/service/template/manage"
	"github.com/ecodeclub/ekit/pool"
	"github.com/google/wire"
	"github.com/gotomicro/ego/core/econf"
	"time"
)

// Injectors from wire.go:

func InitGrpcServer() *ioc.App {
	db := ioc.InitDB()
	notificationDAO := dao.NewNotificationDAO(db)
	notificationRepository := repository.NewNotificationRepository(notificationDAO)
	sonyflake := ioc.InitIDGenerator()
	service := notification.NewNotificationService(notificationRepository, sonyflake)
	channelTemplateDAO := dao.NewChannelTemplateDAO(db)
	channelTemplateRepository := repository.NewChannelTemplateRepository(channelTemplateDAO)
	string2 := ioc.InitProviderEncryptKey()
	providerDAO := dao.NewProviderDAO(db, string2)
	providerRepository := repository.NewProviderRepository(providerDAO)
	manageService := manage.NewProviderService(providerRepository)
	auditService := audit.NewService()
	v := newSMSClients(manageService)
	channelTemplateService := manage2.NewChannelTemplateService(channelTemplateRepository, manageService, auditService, v)
	businessConfigDAO := dao.NewBusinessConfigDAO(db)
	client := ioc.InitRedisClient()
	cache := ioc.InitGoCache()
	localCache := local.NewLocalCache(client, cache)
	redisCache := redis.NewCache(client)
	businessConfigRepository := repository.NewBusinessConfigRepository(businessConfigDAO, localCache, redisCache)
	businessConfigService := config.NewBusinessConfigService(businessConfigRepository)
	callbackLogDAO := dao.NewCallbackLogDAO(db)
	callbackLogRepository := repository.NewCallbackLogRepository(notificationRepository, callbackLogDAO)
	callbackService := callback.NewService(businessConfigService, callbackLogRepository)
	channel := newChannel(v, channelTemplateService)
	taskPool := newTaskPool()
	notificationSender := newSender(notificationRepository, businessConfigService, callbackService, channel, taskPool)
	immediateSendStrategy := sendstrategy.NewImmediateStrategy(notificationRepository, notificationSender)
	defaultSendStrategy := sendstrategy.NewDefaultStrategy(notificationRepository, businessConfigService)
	sendStrategy := sendstrategy.NewDispatcher(immediateSendStrategy, defaultSendStrategy)
	sendService := notification.NewSendService(channelTemplateService, service, sonyflake, sendStrategy)
	txNotificationDAO := dao.NewTxNotificationDAO(db)
	txNotificationRepository := repository.NewTxNotificationRepository(txNotificationDAO)
	dlockClient := ioc.InitDistributedLock(client)
	txNotificationService := notification.NewTxNotificationService(txNotificationRepository, businessConfigService, notificationRepository, dlockClient, notificationSender)
	notificationServer := grpc.NewServer(service, sendService, txNotificationService, channelTemplateService)
	component := ioc.InitEtcdClient()
	egrpcComponent := ioc.InitGrpc(notificationServer, component)
	asyncRequestResultCallbackTask := callback.NewAsyncRequestResultCallbackTask(dlockClient, callbackService)
	notificationScheduler := scheduler.NewScheduler(service, notificationSender, dlockClient)
	sendingTimeoutTask := notification.NewSendingTimeoutTask(dlockClient, notificationRepository)
	txCheckTask := notification.NewTxCheckTask(txNotificationRepository, businessConfigService, dlockClient)
	v2 := ioc.InitTasks(asyncRequestResultCallbackTask, notificationScheduler, sendingTimeoutTask, txCheckTask)
	quotaDAO := dao.NewQuotaDAO(db)
	quotaRepository := repository.NewQuotaRepository(quotaDAO)
	quotaService := quota.NewService(quotaRepository)
	monthlyResetCron := quota.NewQuotaMonthlyResetCron(businessConfigRepository, quotaService)
	v3 := ioc.Crons(monthlyResetCron, businessConfigRepository)
	app := &ioc.App{
		GrpcServer: egrpcComponent,
		Tasks:      v2,
		Crons:      v3,
	}
	return app
}

// wire.go:

var (
	BaseSet              = wire.NewSet(ioc.InitDB, ioc.InitDistributedLock, ioc.InitEtcdClient, ioc.InitIDGenerator, ioc.InitRedisClient, ioc.InitGoCache, local.NewLocalCache, redis.NewCache)
	configSvcSet         = wire.NewSet(config.NewBusinessConfigService, repository.NewBusinessConfigRepository, dao.NewBusinessConfigDAO)
	notificationSvcSet   = wire.NewSet(notification.NewNotificationService, repository.NewNotificationRepository, dao.NewNotificationDAO, notification.NewSendingTimeoutTask)
	txNotificationSvcSet = wire.NewSet(notification.NewTxNotificationService, repository.NewTxNotificationRepository, dao.NewTxNotificationDAO, notification.NewTxCheckTask)
	senderSvcSet         = wire.NewSet(
		newSMSClients,
		newChannel,
		newTaskPool,
		newSender,
	)
	sendNotificationSvcSet = wire.NewSet(notification.NewSendService, sendstrategy.NewDispatcher, sendstrategy.NewImmediateStrategy, sendstrategy.NewDefaultStrategy)
	callbackSvcSet         = wire.NewSet(callback.NewService, repository.NewCallbackLogRepository, dao.NewCallbackLogDAO, callback.NewAsyncRequestResultCallbackTask)
	providerSvcSet         = wire.NewSet(manage.NewProviderService, repository.NewProviderRepository, dao.NewProviderDAO, ioc.InitProviderEncryptKey)
	templateSvcSet         = wire.NewSet(manage2.NewChannelTemplateService, repository.NewChannelTemplateRepository, dao.NewChannelTemplateDAO)
	schedulerSet           = wire.NewSet(scheduler.NewScheduler)
	quotaSvcSet            = wire.NewSet(quota.NewService, quota.NewQuotaMonthlyResetCron, repository.NewQuotaRepository, dao.NewQuotaDAO)
)

func newChannel(
	clients map[string]client.Client,
	templateSvc manage2.ChannelTemplateService,
) channel.Channel {
	return channel.NewDispatcher(map[domain.Channel]channel.Channel{domain.ChannelEmail: channel.NewSMSChannel(newMockSMSSelectorBuilder())})
}

func newSMSSelectorBuilder(
	clients map[string]client.Client,
	templateSvc manage2.ChannelTemplateService,
) *sequential.SelectorBuilder {

	providers := make([]provider.Provider, 0, len(clients))
	for name := range clients {
		providers = append(providers, sms.NewSMSProvider(
			name,
			templateSvc,
			clients[name],
		))
	}
	return sequential.NewSelectorBuilder(providers)
}

func newSMSClients(providerSvc manage.Service) map[string]client.Client {
	ctx, cancelFunc := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancelFunc()

	entities, err := providerSvc.GetByChannel(ctx, domain.ChannelSMS)
	if err != nil {
		panic(err)
	}
	clients := make(map[string]client.Client)
	for i := range entities {
		var cli client.Client
		if entities[i].Name == "aliyun" {
			c, err1 := client.NewAliyunSMS(entities[i].RegionID, entities[i].APIKey, entities[i].APISecret)
			if err1 != nil {
				panic(err1)
			}
			cli = c
			clients[entities[i].Name] = cli
		} else if entities[i].Name == "tencentcloud" {
			c, err1 := client.NewTencentCloudSMS(entities[i].RegionID, entities[i].APIKey, entities[i].APISecret, entities[i].APPID)
			if err1 != nil {
				panic(err1)
			}
			cli = c
			clients[entities[i].Name] = cli
		}
	}
	return clients
}

func newMockSMSSelectorBuilder() *sequential.SelectorBuilder {
	return sequential.NewSelectorBuilder([]provider.Provider{metrics.NewProvider("ali", tracing.NewProvider(provider.NewMockProvider(), "ali"))})
}

func newTaskPool() pool.TaskPool {
	type Config struct {
		InitGo           int           `yaml:"initGo"`
		CoreGo           int32         `yaml:"coreGo"`
		MaxGo            int32         `yaml:"maxGo"`
		MaxIdleTime      time.Duration `yaml:"maxIdleTime"`
		QueueSize        int           `yaml:"queueSize"`
		QueueBacklogRate float64       `yaml:"queueBacklogRate"`
	}
	var cfg Config
	if err := econf.UnmarshalKey("pool", &cfg); err != nil {
		panic(err)
	}
	p, err := pool.NewOnDemandBlockTaskPool(cfg.InitGo, cfg.QueueSize, pool.WithQueueBacklogRate(cfg.QueueBacklogRate), pool.WithMaxIdleTime(cfg.MaxIdleTime), pool.WithCoreGo(cfg.CoreGo), pool.WithMaxGo(cfg.MaxGo))
	if err != nil {
		panic(err)
	}
	err = p.Start()
	if err != nil {
		panic(err)
	}
	return p
}

func newSender(repo repository.NotificationRepository,
	configSvc config.BusinessConfigService,
	callbackSvc callback.Service, channel2 channel.Channel,

	taskPool pool.TaskPool,
) sender.NotificationSender {
	s := sender.NewSender(repo, configSvc, callbackSvc, channel2, taskPool)
	return sender.NewTracingSender(sender.NewMetricsSender(s))
}
